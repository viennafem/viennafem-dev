

//Basic ViennaFEM workflow:


// Step 1:  Configure desired FEM:
  struct MyFEMConfig  //can be either compile time or a predefined run time name like 'fem_config'.
  {

    ///////// Specify the following (compile time, run time) /////////////////
    - how to handle basis functions (don't exclude compile time FEM prematurely - it has superior run time efficiency at the expense of higher compilation times)
    - whether Dirichlet boundary conditions should be written directly to load vector, or whether they are written to the matrix first and then (magically) removed
    - which discrete space to use *for that particular unknown* (allows mixed FEM)
    - which key to use for DOF-mapping
    - which key(s) to use for boundary conditions


    ////// Notes on former approach:///////////
    typedef ScalarTag                         ResultDimension;   //Not good, because does not allow mixed FEM or different ansatz spaces for the individual unknowns.
    typedef SegmentConnectionKey<0>           SegmentConnection; //Has been necessary only because of the association of data with a segment. Should not be needed any longer.

    //Specification of at most three boundary data keys is obviously limited to three unknown variables by design.
    typedef BoundaryKeyType<11>                BoundaryData;
    typedef BoundaryKeyType<12>                BoundaryData2;
    typedef BoundaryKeyType<13>                BoundaryData3;
  };



// Step 2: Specify PDEs (i.e. weak formulation) to solve using ViennaMath:

  //for Poisson:
  unknown   u;
  test_func v;

  weak_formulation = equation( integral(Omega, grad(u) * grad(v), some_integration) ,
                              /* = */
                               integral(Omega, func, some_integration) );

  //for Lam√© (elasticity)
  vector_unknown u_vec = make_vector(u1, u2, u3);
  vector_test_func v_vec = make_vector(v1, v2, v3);

  weak_formulation = equation(   integral(Omega, tensor_prod(grad(u_vec), grad(v_vec)) + div(u_vec) * div(v_vec), some_integration) ,   //exact equation look a little bit different, but [KR] can't remember it right now...
                                 integral(Omega, load_vec, some_integration) );



// Step 3: Assemble system (with optional internal solution step)

  for_each(segment.begin(), segment.end(), Assembler(weak_formulation, matrix, rhs, config) );   //assembly into (matrix, rhs) only
  for_each(segment.begin(), segment.end(), Solver(weak_formulation, config) );                   //result can be either written to domain or plain result vector returned
  


// Step 4: Solution of system (if not included in step 3)
 
  result = solve(matrix, rhs);


// Step 5: Postprocess:

  segment_function  seg_func(result, config);   //a function object that can be evaluated in every point inside the segment
  domain_function   dom_func(result, config);   //a function object that can be evaluated in every point inside the domain

  norm_h1(seg_func);        //compute norm in segment
  norm_l2(domain_func);     //compute norm in domain

